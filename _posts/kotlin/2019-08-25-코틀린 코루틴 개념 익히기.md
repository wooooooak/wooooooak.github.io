---
layout: post
title: 코틀린 코루틴(coroutine) 개념 익히기
category: Kotlin
tags: [coroutine, study]
comments: true
---

앞서 코루틴을 이해하기 위한 두 번의 발악이 있었지만, 이번에는 더 원론적인 코루틴에 대해서 알아보려 한다. 코루틴의 개념이 정확하게 서야 응용도 가능하기에 이번 포스팅으로 개념을 확실하게 알아갔으면 좋겠다.

## 인트로

![image](https://user-images.githubusercontent.com/18481078/63651508-57934c80-c790-11e9-9bb0-872739ada67e.png)

코루틴은 코틀린만의 것이 아니다. 이름이 비슷해서 코틀린의 것이라고 생각할 수 있지만 파이썬, C#, Go, Javascript 등 여러 언어에서 지원하고 있는 개념이다. Javascript를 사용하고 있으면서 async await를 사용하고 있다면 이미 코루틴을 사용해본 경험이 있는것이다. 아무튼 코루틴은 새로운 개념, 새로운 기술이 아니라 프로그래밍이 세상에 나온 초창기 부터 존재하던 개념이다.

#### 우리가 코틀린 코루틴을 공부해볼 가치가 있는 이유

![image](https://user-images.githubusercontent.com/18481078/63651520-7e518300-c790-11e9-9fd6-578fd819bb73.png)

앱이든 웹이든 비동기 처리가 핵심인 클라이언트 프로그래밍에서 지금까지 가장 핫한 키워드는 [rx programming](http://reactivex.io/)일 것이다. 그러나 구글이 안드로이드 공식 언어를 자바에서 코틀린으로 변경한 이후, 최근 들어 대표적인 샘플 예제들인 [bluprint](https://github.com/googlesamples/android-architecture/tree/master)와 [sunflower](https://github.com/googlesamples/android-sunflower) 앱의 비동기처리를 coroutine으로 바꾸었다(아직 rx로 짠 코드를 특정 브랜치로 남겨놓고 있긴하다). Rx 라이브러리를 걷어내고 코루틴으로 새로 작성한 것이다. 이와 더불어 상당히 많은 외국 자료들이 올라오고있다. 그 이유는 코루틴을 사용하면 비동기 처리가 너무나도 쉽게 이루어 질 수 있기 때문이라고 생각한다. 이 이유 만으로 코루틴을 공부해볼 가치는 충분하다.

## 코루틴이란!

이제 코루틴이 무엇인지 한번 알아보자. 코루틴을 3가지 키워드 정도로 알아보려고 한다.

1. **협력형 멀티 태스킹**
2. 동시성 프로그래밍 지원
3. 비동기 처리를 쉽게 도와줌

가장 중요한 개념은 1번, 협력형 멀티 태스킹이다. 사실 협력형 멀티태스킹에 대한 내용을 이해한다면 코루틴이란 것을 다 알게되는 것이다. 그러나 코루틴을 내 것으로 만들기 위해서는 동시성 프로그래밍과, 비동기 처리에 대한 관점에서 이해하는 것도 중요하다.

### 협력형 멀티태스킹

협력형 멀티태스킹을 프로그래밍 언어로 표현하자면
Co + Routine 이다.
**Co**라는 접두어는 "협력", "함께"라는 의미를 지니고 있다. **Routine**은 하나의 태스크, 함수 정도로 생각하면 된다. 더 진도를 나가기에 앞서 Routine에 대해서 좀 더 알아보자.

Routine에는 우리가 흔히 알고있는 main routine과 sub routine이 존재한다. 이런 단어들이 생소할 수도 있지만, 우리가 늘 작성하고 있는 코드들이다.
![image](https://user-images.githubusercontent.com/18481078/63651600-6a5a5100-c791-11e9-87d1-3f81dc9b415d.png)

위의 자바 코드를 보자(자바 개발자가 대다수인 사내 세미나 목적으로 만든 자료라서 Java코드가 섞여있다...ㅠ).
`main`함수가 말 그대로 Main 함수다. 메인이 되는 함수인 것이다. 그리고 메인이 되는 함수는 다른 서브 함수인 plusOne을 호출한다. 우리가 짜는 프로그램은 흔이 이렇게 되어있다. 너무 익숙한 흐름이라 어려울 것이 전혀없다.

그런데 이 Sub Routine을 살펴보면 한가지 특징이 있다. 아래 그림을 보자.
![image](https://user-images.githubusercontent.com/18481078/63651648-f8ced280-c791-11e9-9917-1b034b855e84.png)

Sub Routine은 루틴에 진입하는 지점과 루틴을 빠져나오는 지점이 명확하다. 즉, 메인 루틴이 서브루틴을 호출하면, 서브루틴의 맨 처음 부분에 진입하여 `return`문을 만나거나 서브루틴의 닫는 괄호를 만나면 해당 서브루틴을 빠져나오게 된다.

다시 코드로 돌아가 보자(이번엔 코틀린 코드다...ㅎ;).

![image](https://user-images.githubusercontent.com/18481078/63651659-303d7f00-c792-11e9-9aae-0b756bb5e8a8.png)

메인 쓰레드가 `plusOne`이라는 서브루틴에 진입한다. 당연히 코드는 처음부터 진입이 되어 맨 윗줄부터 실행이 될것이고, 그 아래 코드들을 쭉쭉 실행해서 `return`문을 만나면 서브루틴을 호출했던 부분으로 탈출한다. 그리고 진입점과 탈출점 사이에 쓰레드는 블락되어있다. 우리가 늘 짜는 코드라 이해가 쉽다.

그러나 코루틴(Coroutine)은 조금 다르다.
![image](https://user-images.githubusercontent.com/18481078/63651705-a0e49b80-c792-11e9-9924-eb737b813065.png)

이때까지 코루틴을 사용하지 않았다면 혼란스러운 그림일 수도 있지만 이해해보자!

코루틴도 routine이기 때문에 하나의 함수로 생각하자. 그런데 이 함수에 진입할 수 있는 진입점도 여러개고, 함수를 빠져나갈 수 있는 탈출점도 여러개다. 즉, 코루틴 함수는 꼭 `return`문이나 마지막 닫는 괄호를 만나지 않더라도 언제든지 중간에 나갈 수 있고, 언제든지 다시 나갔던 그 지점으로 들어올 수 있다.

이것도 역시 코드로 알아보자.
![image](https://user-images.githubusercontent.com/18481078/63651752-5fa0bb80-c793-11e9-80e7-9384265cf442.png)

`drawPerson`이라는 함수가 있다. 이 함수 안에는 `startCoroutine`이라는 코루틴 빌더가 있다(**실제로 startCoroutine이라는 빌더는 존재하지 않는다. 실제 코루틴 라이브러리에는 다른방식으로 코루틴을 만들지만 여기서는 이해를 위해 쉽게 startCoroutine이라고 사용한다**).

`startCoroutin`이라는 코루틴을 만나게 되면 해당 함수는 코루틴으로 작동할 수 있다. 따라서 언제든 함수실행중간에 나갈수도 있고, 다시 들어올수도 있는 자격이 부여되는 것이다. 언제 코루틴을 중간에 나갈수 있을까? suspend로 선언된 함수를 만나면 코루틴 밖으로 잠시 나갈 수 있다.

이제 순서를 따라 가보자.

1. 쓰레드의 Main함수가 `drawPerson()`을 호출하면 `startCoroutine`블럭을 만나 코루틴이 된다. 위에도 말했듯이 이제 `drawPerson()`은 진입점과 탈출점이 여러개가 되는 자격이 주어진 것이다.

2. 코루틴이 실행이 되었지만, suspend를 만나기 전까지는 그다지 특별한 힘이 없다. suspend로 정의된 함수가 없다면 그냥 마지막 괄호를 만날 때 까지 계속 실행된다. 그러나 drawHead()는 suspend 키워드로 정의되어진 함수다. 따라서 drwaHead() 부분에서 더 이상 아래 코드를 실행하지 않고 drawPerson() 코루틴 함수를 탈출한다.

3. 메인 쓰레드가 해당 코루틴을 탈출했다. 그렇다고 쓰레드가 놀고 있을리는 없다. 우리가 짜놓은 다른 코드들을 실행할 수도 있고, 안드로이드라면 다른 애니메이션 처리를 할 수도 있다. 그러나 **Head는 어디선가 계속 그려지고 있다.** `drwaHead()`는 2초가 걸리는 suspend 함수였음을 기억하자. 이 함수부분에서 코루틴을 탈출했지만, 이 함수의 기능은 메인쓰레드에서 동시성 프로그래밍으로 작동하고 있을수도 있고, 다른 쓰레드에서 돌아가고 있을 수도 있다. 그것은 개발자가 자유롭게 선택할 수 있다(이해가 되지 않아도 좋다. 바로 뒤에서 다시 설명한다!).

4. 그렇게 메인쓰레드가 다른 코드들을 실행하다가도, `drawHead()`가 제 역할을 다 끝내면 다시 아까 탈출했던 코루틴 `drawPerson()`으로 돌아온다. 아까 멈추어놓았던 `drawHead()` 아래인 `drawBody()`부터 재개(resume)된다.

위의 과정에서 보았듯이 코루틴 함수는 언제든지 나왔다가 다시 들어올 수 있다. 이 대목에서 이미 눈치를 챈 분들도 있을것 같은데, 코루틴의 이런 성향은 동시성 프로그래밍과 밀접한 관계가 있다.
