---
layout: post
title: 코틀린 프로퍼티(kotlin property)
category: Kotlin
tags: [lambda, 프로퍼티, 접근자]
comments: true
---

코틀린은 프로퍼티를 언어 기본 기능으로 제공한다. 프로퍼티란 무엇일까? 프로퍼티란 필드와 접근자를 통칭하는 것이다. 일반적인 자바빈 클래스인 Person을 보면서 정확히 알아보자.

```java
public class Person {
    private final String name;
    private boolean isMarried;

    public Person(String name, int age, boolean isMarried) {
        this.name = name;
        this.age = age;
        this.isMarried = isMarried;
    }

    public String getName() {
        return this.name;
    }

    public void setIsMarried(boolean isMarried) {
        this.isMarried = isMarried;
    }

    public boolean getIsMarried() {
        return this.isMarried;
    }
}
```

자바에서는 데이터를 **필드(field)**에 저장한다. `name`과 `isMarried`라는 데이터를 Person클래스의 필드에 저장한 것이다. 한편 각 데이터마다 적용되는 getter와 setter를 **접근자**라 부른다. 이 접근자를 통해서 가시성이 private인 데이터들에 접근할 수 있다.

위의 자바 코드에서 Person클래스 필드에 들어가는 데이터들이 점점 증가한다면 getter와 setter같은 보일러플레이트 코드가 지저분하게 많아진다. 코틀린에서는 위의 Person클래스를 간단하게 정의할 수 있다.

```kotlin
class Person(val name: String, var isMarried: Boolean)
```

이 한줄의 코틀린 코드는 21줄의 자바 코드와 완전히 동일한 코드다. 코틀린의 기본 가시성이 public이기 때문에 getter와 setter의 가시성을 그대로 놔둬도 된다. 그런데 기본 가시성이 public이라면, 필드에 저장된 데이터의 가시성도 public이라고 생각할 수 있지만, **생성자에 선언된 데이터는 private이 된다.** 반면 **일반 클래스 필드에 넣은 데이터는 private으로 지정해 주지 않을 경우 public이다.**

자세히보면 자바코드에서 setter를 제공하지 않는 `name`은 `val`로 선언하였고, getter와 setter모두 제공하는(조회화 변경을 모두 허용하는) `isMarried`는 var로 선언했다. 익히 알고있듯이 val은 불변, var은 가변 데이터를 선언할 때 사용한다. 이와 같은 맥락으로 val로 선언한 `name`은 setter가 생성되지 않는다. 이 부분을 코드로 보자면 아래와 같다.

```kotlin
class Person {
    val name: Int
        get() {
            return this.age
        }

    var isMarried: Boolean
        get() {
            return this.isMarried
        }
        set(isMarried: Boolean) {
            this.isMarried = isMarried
        }
}
```

`val`로 선언한 name의 경우 setter가 없다. setter를 만들고 싶어도 val은 불변이기에 만들 수 없다(억지로 만드려고 하면 컴파일에러가 뜬다). 참고로 위에서 `get()`과 `set()`을 정해준 것은 커스텀 접근자이다. 기본적으로는 코틀린 클래스를 만들 때 생성자에 넣어준 데이터들에 대하여 get()과 set()이 숨겨져 있으나, 위의 코드처럼 명시적으로 적어줄 수 있다. 그말은 getter와 setter를 커스텀 할 수도 있다는 뜻이다. 추가적으로 위 코드는 클래스의 생성자가 아닌 필드에서 데이터를 선언했으므로 데이터 가시성은 public이다.

## 핵심

코틀린 생성자로 넘겨준 데이터는 기본적으로 private이고, 자동으로 getter와 setter(setter의 경우 var에 한해서)가 만들어 지기 때문에 일반적인 자바빈과 동일하다.
