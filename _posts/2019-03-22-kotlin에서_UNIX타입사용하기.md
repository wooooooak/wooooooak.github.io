---
layout: post
title: 코틀린에서 Unix 시간 사용 시 주의점
category: Kotlin
tags: [kotlin, unix_time]
comments: true
---

Unix 시간 타입은 숫자로만 이루어져 있다. 1970-01-01 00:00:00 시간을 0으로 시작하여 1초마다 1씩 증가하는 값이다.

현재 시간 2019-03-22 19:54:23 을 기준으로 Unix 시간은 **1553252063**이 된다. 1970-01-01 00:00:00 이후로 1553252063초가 지난 것이다.

[http://chongmoa.com/unixtime](http://chongmoa.com/unixtime) 이 링크에서 날짜를 unix 타입으로 쉽게 변환 할 수 있다. 

## 코틀린에서 사용하기
그런데 위 사이트에서 얻어온 unix 값을 가지고 kotlin 또는 Java에서 날짜로 변경하면 원하는 값이 나오지 않는다. 아래의 코드를 보자.

```kotlin
fun main(args: Array<String>) {
    println(Date(1553252063)) // Mon Jan 19 08:27:32 KST 1970
}
```
`1553252063`은 웹 사이트에서 변환했을 때 날짜로 **2019-03-22 19:54:23** 이지만 코틀린에서는 한국 시간 1970년대라고 한다. 연도 뿐만 아니라 모든 값이 엉터리로 나온다. 이와 같이 출력되는 이유는, 일반적인 UNIX 시간은 초단위로 1씩 증가하는 반면 코틀린과 자바같은 경우는 밀리세컨드 단위로 1씩 증가하는 규칙을 가지고 있기 때문이다(컴퓨터는 0.001초도 의미 있는 값이기 때문). 코틀린과 자바에서는 밀리세컨드(0.001초)마다 unix 시간이 1씩 증가하므로 당연히 일반적인 유닉스 타임보다  표면적으로 보이는 유닉스 타임 값이 클 수 밖에 없다. 일반적인 유닉스 값은 1초에 1씩 증가하는 반면, 프로그램에서는 1초에 1000씩 증가한다(1000 밀리세컨드가 1초다).

따라서 외부로부터 일밬적인 유닉스 값을 받아와서 프로그램에 적용하고 싶다면, 일반적인 유닉스 타임에 자바, 코틀린 형식에 맞도록 1000L을 곱해주면 된다. 주의 할 점은 Int로 1000을 곱하는게 아니라 Long타입으로 곱해야 한다. Int로 1000을 곱해주면 overflow가 일어나 또 한번 원하지 않는 값이 출력될 수 있다. 

```kotlin
fun main(args: Array<String>) {
    println(Date(1553252063 * 1000L)) // Fri Mar 22 19:54:23 KST 2019
    println(Date(1553252063 * 1000)) // Sun Dec 14 17:05:01 KST 1969
}
```
Long 타입으로 곱하면 정상적인 값이 나오지만 Int 1000을 곱해주면 이상한 값이 출력되는 것을 볼 수 있다.