---
layout: post
title: 멀티모듈 프로젝트에서 인터페이스의 위치에 관하여
category: Architecture
tags: [muti_module, MVVM]
comments: true
---

# 아키텍처

소프트웨어 아키텍쳐 진화는 앱의 규모가 커짐에 따라 서서히 발전해왔다. 아주 작은 기능과 낮은 사용자 기대가 보편적이었을 때는 아키텍쳐에 대한 논란이 많지않으나, 요구사항이 증가하고 사용자의 기대가 높아지면 높아질수록 더더욱 유지보수하기 편한 아키텍쳐들이 고안되어져 왔다. 안드로이드 쪽을 보면 MVVM과 MVI를 많이 사용하고있는 것으로 보인다. 이들 역시 처음부터 짠! 하고 나온게 아니라 복잡해 지는 앱 코드들에 발맞춰 점점 더 진화해온 결과이다.

# 멀티 모듈

최근(?)에는 멀티모듈 적용에 관한 세미나와 자료들이 많이 올라오고 있다.
멀티모듈의 장점은 크게 코드의 재사용성, 아키텍쳐 가이드, 빌드속도 관점에서 간단히 바라보자.

1. 재사용성 - 우리는 이미 반복되어 사용될 기능들은 함수로 빼내어 사용한다. 더 나아가면 라이브러리로 만들어 사용하기도 한다. 이와 같은 이유로 하나의 프로젝트 내에서 재사용될 코드를 모듈로 뽑아 관리할 수 있고, 다른 앱과 공유할 기능들을 모듈로 뽑아낼 수도 있다.

2. 실수 방지 - 안드로이드 앱 아키텍쳐들을 살펴보면 대부분 View를 그리는 행위와 View를 위한 데이터 핸들링 로직, 비즈니스 로직을 담당하는 부분 등등을 명확히하여 유지보수를 높이자는 취지에 있다(물론 어떻게 부분을 나눌 것인지 정답은 없으며 실제로 클린 아키텍쳐를 포함해 많은 아키텍쳐가 있다). 나눠진 부분들은 서로 관심사가 다르기 때문에 자연스레 패키지로 나누는 경우가 많으나, 한 모듈안에서 패키지로만 나누다 보면 이해도가 부족한 개발자가 `viewModel`을 참조하는 `repository`를 만들어 버릴수 도 있다. 이럴 때 각 레이어를 모듈로 쪼개어 놓고 의존성을 명시해 놓으면 잘못된 참조가 불가능해 지는 이점을 얻을수 있다.
   ![image](https://user-images.githubusercontent.com/18481078/93664488-507d6180-faaa-11ea-920b-40c28f90c37d.png)

3. 빌드 속도 - 각 모듈은 하나의 프로젝트에 있다 하더라도 각자의 빌드 시스템을 가지며 독립적으로 빌드가 수행된다. A, B, C 모듈이 존재할 때, 모두 하나의 프로젝트에 있다 하더라도 B모듈만 변경이 있었다면 B모듈만 빌드를 하면 된다는 의미이다. 따라서 모든 모듈을 한 번에 수정하지 않았다면 빌드속도는 단축될 수 있다(단 의존성이 있는 모듈은 함께 빌드된다).

# 각 모듈의 인터페이스 위치에 관하여

모바일 앱을 멀티 모듈로 구성하는 방법은 여러가지가 있을 수 있다(안드로이드를 예로 설명하지만, 사실 멀티모듈이라면 플랫폼과 무관한 이야기다). `Presention Module(View + ViewModel)`, `Domain Module(UseCase)`, `Data Layer(Repository, DataStore)` 이렇게 세가지로 간단히 나눌수 있는 반면, 각 기능별(로그인, 채팅, etc..)로 모듈을 나누는 프로젝트도 있다. 어떤식으로 모듈을 나누더라도 필연적으로 하나의 모듈이 다른 모듈을 참조할 수 밖에 없는 상황이 생긴다.
![image](https://user-images.githubusercontent.com/18481078/93664721-f8dff580-faab-11ea-886a-3d69e248a968.png)
예를들어 위의 그림처럼 `Presentation Module`과 `Data Module`로 간단히 나누었다고 한다면, `Presentaion Module`은 `DataModule의 Repository` 인터페이스를 알아야만 한다(Repository 구현체가 아닌 인터페이스를 알아야 한다).

## Interface 위치는 어디에?

그렇다면 Repository Interface 코드는 어느 모듈에 두어야 할까?

두가지 선택이 있을 것이다.

1. Repository 인터페이스니까 Repository들이 모여있는 Data 모듈에 둔다.
2. Presentation에게 중요한 정보이니 Presentation 모듈에 둔다.

**다수의 사람들이 1번을 선택했다.** 이유는 크게 두 가지.

1. 말그대로 Repository의 인터페이스니까 Repository들이 모여있는 Data 모듈에 두는게 상식적으로 맞는 것 같다는 이유
2. Repository 인터페이스가 Presentation 모듈에 있다면 Repository의 구현이 Presentation에 의존한다는 이유

두 번째 이유에 대해서 조금 더 생각해볼 필요가 있을것 같았다.

### 인터페이스의 본질

먼저 인터페이스에 대해 조금 본질적으로 생각해보자. 우리는 왜 Presentation 모듈의 viewModel이 repository의 구현체가 아니라 인터페이스를 참조 하게끔 개발할까? 아는 이야기겠지만 다형성과 느슨한 결합 때문이다. `viewModel` 입장에서 중요한건 데이터를 가져오고 추가할 수 있는 `repository`와 협력하는 것 뿐이지 그게 실제로 어떤 구체적인 `repository` 클래스인지는 관심사가 아니다. 어떤 방법으로 데이터를 가져오는지는 관심없다는 이야기다. 뷰모델이 Repository객체에게 바라는(요구하는) 기능(public method)들만 모아 하나의 타입을 만들고나서 단지 그 타입의 객체를 주입받아 사용하기만 하면 되는 것이다. 이것을 가능하게 하는 것이 `Interface`이다.

바로 위에서 뷰모델이 원하는 기능(public interface)을 수행할 수 있는 타입(Interface)의 객체를 주입받는다고 하였다. **즉 Type(Interface)은, 특정 타입의 객체를 사용하는 클라이언트 입장에서 훨씬 중요한 것이다.**

인터페이스는 클라이언트가 기대하는 바에 따라 분리돼야만 한다. 예를들어 뷰모델이 기대하는 `repository`의 기능이 오직 `getFriendList()` 하나뿐이라면, `viewModel`에게는 오직 `getFriendList()` 메서드만 노출되어야 한다([인터페이스 분리의 원칙 - ISP](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4_%EB%B6%84%EB%A6%AC_%EC%9B%90%EC%B9%99)).

다시 1번을 택한 이유 중 두번째 이유로 돌아가보자.
**"`B` Interface가 `A` 모듈에 있다면 `B` 구현이 `A`에 의존해버린다"**

이제 처음 보았을때랑 조금 다른 시각으로 보일지 모르겠다. A모듈의 `viewModel`에서 `repository`에게 기대하는 기능(public method)이 바뀌었으면 B모듈의 `repository`의 구현도 바뀔수 밖에 없는게 당연하다. 기대하는 행위(public method)가 달라졌는데 어떻게 바꾸지 않겠는가?(바꾸지 않으면 컴파일조차 안될 것이다).
이해가 어렵다면 역이 성립되는지 생각해보자. B인터페이스가 B모듈에 존재한다 하더라도 결국 B모듈의 `repository interface`를 사용하는 측은 A모듈이기 때문에, A가 요구하는 public method가 바뀌면 당연히 인터페이스를 포함하여 B의 구현도 바뀐다는 의미다. 즉 `b`의 구현과 명세 모두 `A`에 의존하는건 변함이 없다.

이 관점까지만 생각해 보았을때의 결론은 **`A`, `B` 모듈어디에 두어도 크게 상관없다**이다. 빌드 관점에서도 생각해보자.

## 빌드 관점에서도 생각해보기

우리는 gradle이 변하지 않은 모듈을 재빌드 하지 않는다는 사실을 알고있다. 하지만 A모듈에서 B모듈의 어떠한 것이라도 참조하고 있다면(import하고 있다면), B모듈의 코드가 수정될 경우 A모듈도 수정된다. 다른 모듈을 참조하고 있지 않은 모듈만 수정될 경우 gradle은 그 모듈만 수정한다.

Repository Interface를 어느 모듈에 두어도 의존성을 완전히 없앨 수는 없기 때문에, 개발자의 결정에 따라 필히 어느 한 모듈은 다른 모듈이 빌드될때 함께 빌드되어야만 한다. 따라서 빌드 관점에서도 역시 어느 모듈에 둔다고 해서 큰 차이는 없는것 같다.
참고로 `./gradlew assembleDebug -profile` 로 빌드하면 어떤 모듈이 변경되고 어떤 모듈이 재빌드 되지 않았는지에 대한 정보가 html로 나타난다.

## 결론

정답이 없는 문제인것 같다. 개인적으로는 내가 만든 모듈의 범용성에 따라서 결정해야 하는 문제가 아닐까 생각한다. 모듈을 그 프로젝트 내에서만 사용하도록 설계하였다면 빌드 속도 개선에 큰 의미가 있으므로 이래나 저래나 크게 상관이 없으나, 모듈을 이 프로젝트 뿐만 아니라 여러 앱 혹은 여러 모듈에서 사용하게끔 의도하였다면 자신이 인터페이스를 들고있는게 좋을것 같다. 예를들어 자동차 인터페이스를 생각해보자. 전진, 후진, 좌회전, 우회전, 정지, 클락션, 깜빡이 등의 기능들이 모여 자동차 인터페이스가 된다. 세상 모든 사람들에게 대중적으로,범용적으로 쓰여야하기에 이 인터페이스는 사용자가 가지고 있지 않고 자동차를 관리하는 모듈이 주체적으로 가지고 있어야 한다(특정 사람이 인터페이스를 바꾼다고 거기에 맞춰줄수 없는 일이다). 반면 특정 집단에서만 특수하게 사용될거라 범용성이 없어도 되는 자동차의 경우, 인터페이스 위치는 크게 중요하지 않다.
